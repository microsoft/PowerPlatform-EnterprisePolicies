parameters:
# Official tasks include determining a 'proper' version with GitVersion and enabling code signing
- name: official
  type: boolean

steps:
- checkout: self
      
- ${{ if parameters.Official }}:

  - task: PowerShell@2
    displayName: dotnet tool install GitVersion.Tool
    inputs:
      targetType: inline
      script: dotnet tool install GitVersion.Tool --global --version 5.11.1

  - task: PowerShell@2
    displayName: dotnet gitversion
    inputs:
      targetType: inline
      script: dotnet gitversion -output buildserver

- task: NuGetAuthenticate@1

- task: DotNetCoreCLI@2
  displayName: üîÑ Dotnet restore
  env:
    SYSTEM_ACCESSTOKEN: $(System.AccessToken)
  inputs:
    command: 'restore'
    projects: '$(Build.SourcesDirectory)\build\build.proj'
    selectOrConfig: 'config'
    nugetConfigPath: $(Build.SourcesDirectory)\nuget.config

- task: PowerShell@2
  displayName: Get the PackageSource from NugetConfig
  inputs:
    pwsh: true
    targetType: 'inline'
    script: |
      Write-Host "Reading content from $nugetConfigPath"
      $nugetConfigPath = "$(Build.SourcesDirectory)/nuget.config"
      Write-Host "NugetConfigPath: $nugetConfigPath"
      if (-not (Test-Path $nugetConfigPath)) {
        throw "Unable to find $($nugetConfigPath)"
      }
      # Load the XML content from the NugetConfig file
      [xml]$nugetConfigContent = Get-Content -Path $nugetConfigPath

      # Get the packageSources node
      $packageSources = $nugetConfigContent.configuration.packageSources
      if ($packageSources) {
        foreach ($addNode in $packageSources.add) {
          if ($addNode.value -like '*/nuget/*') {
            # Get the first node in packageSources
            $packageSource = $addNode.value
            Write-Host "Original value: $packageSource"
            # Replace v3/index.json with v2
            if ($packageSource -like '*v3/index.json') {
              $packageSource = $packageSource -replace 'v3/index.json', 'v2'
              Write-Host "Updated PackageSource value: $packageSource"
            }
            Write-Host "Setting PackageSource variable with the value : $packageSource"
            Write-Host "##vso[task.setvariable variable=PackageSource]$packageSource"
            Write-Host "Created PackageSource variable with the value : $(PackageSource)"
            break
          }
        }
      }

- task: PowerShell@2
  displayName: Import Powershell Modules
  env:
    SYSTEM_ACCESSTOKEN: $(System.AccessToken)
    MODULES_JSON: '[{"Name": "Microsoft.PowerShell.PlatyPS", "Version": "1.0.1"}]'
  inputs:
    targetType: 'inline'
    script: |
      [string]$modulesjson = "$($env:MODULES_JSON)"
      [string]$PackageSource = "$(PackageSource)"
      [string]$PackageSourceName = "BICPSGalleryUpstream"

      Write-Host "##[Debug]modulesjson: $modulesjson."
      Write-Host "##[Debug]env:MODULES_JSON: $($env:MODULES_JSON)"

      [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
      $feedUri = $PackageSource
      Write-Host "##[debug]Original FeedUri: $feedUri"

      $patToken = $env:SYSTEM_ACCESSTOKEN | ConvertTo-SecureString -AsPlainText -Force
      $credentialsObject = New-Object System.Management.Automation.PSCredential("ONEBRANCH_TOKEN", $patToken)

      # Install modules in common location so that they are accessible
      $customPath = "C:\Windows\system32\WindowsPowerShell\v1.0\Modules"
      Write-Host "##[debug] Install Powershell modules in location:" $customPath
      $env:PSModulePath += ";$customPath"
      Write-Host "##[debug] PowerShell Modules Path: $env:PSModulePath"

      $psGallery = Get-PSRepository -Name "PSGallery" -ErrorAction SilentlyContinue
      if ($null -ne $psGallery) {
        Write-Output "##[debug] Removing default PS Gallery" # To satisfy network isolation
        Unregister-PSRepository -Name $psGallery.Name -ErrorAction SilentlyContinue -Verbose
      }

      Write-Output "##[debug] Register PSRepository for $($feeduri)"
      Register-PSRepository -Name $PackageSourceName `
        -SourceLocation $feedUri `
        -PublishLocation $feedUri `
        -InstallationPolicy Trusted `
        -Credential $credentialsObject `
        -ErrorAction SilentlyContinue `
        -Verbose
      Write-Host "PS Repository registered successfully."

      if (-not [string]::IsNullOrEmpty($modulesjson)) {
        $modules = $modulesjson | ConvertFrom-Json
        Write-Host "##[Debug]modules: $modules."
      }
      else {
        Write-Host "##[error]Error: No modules specified in the input JSON." -ForegroundColor Red
        exit 1
      }
      foreach ($module in $modules) {
        # Try to install the module
        try {
          $moduleName = $module.Name
          $moduleVersion = $module.Version
          Write-Host "Installing module $moduleName, version $moduleVersion ..." -ForegroundColor Yellow
          Save-Module -Name $moduleName -RequiredVersion $moduleVersion -Path $customPath -Repository $PackageSourceName -Credential $credentialsObject -Verbose -Force
          Install-Module -Name $moduleName -RequiredVersion $moduleVersion -Repository $PackageSourceName -Credential $credentialsObject -Verbose -Force -AllowClobber
          Import-Module $moduleName -RequiredVersion $moduleVersion -Verbose -Force
          Write-Host "Module $moduleName installed successfully." -ForegroundColor Green
        }
        catch {
          Write-Host "Failed to install module $module due to exception $_" -ForegroundColor Red
        }
      }

- task: PowerShell@2
  displayName: üß™ Test Scripts (Windows)
  inputs:
    filePath: $(Build.SourcesDirectory)\tools\PowerShell\EnterprisePoliciesScripts\Build\build.ps1
    arguments: '-Tasks @("Test")'

- task: PowerShell@2
  displayName: üß™ Test Scripts (Core)
  inputs:
    pwsh: true
    filePath: $(Build.SourcesDirectory)\tools\PowerShell\EnterprisePoliciesScripts\Build\build.ps1
    arguments: '-Tasks @("Test")'

- task: PublishTestResults@2
  displayName: üì∞ Publish Test Results
  inputs:
    testResultsFormat: 'NUnit'
    testResultsFiles: '$(Build.SourcesDirectory)\tools\PowerShell\EnterprisePoliciesScripts\Build\TestResult.xml'
  condition: always()

- task: PublishCodeCoverageResults@2
  displayName: üì∞ Publish Code Coverage
  inputs:
    summaryFileLocation: '$(Build.SourcesDirectory)\tools\PowerShell\EnterprisePoliciesScripts\Build\coverage.xml'
    pathToSources: '$(Build.SourcesDirectory)\tools\PowerShell\EnterprisePoliciesScripts'
    failIfCoverageEmpty: true
  condition: always()

- task: PowerShell@2
  displayName: üèóÔ∏è Build Scripts
  inputs:
    pwsh: true
    filePath: $(Build.SourcesDirectory)\tools\PowerShell\EnterprisePoliciesScripts\Build\build.ps1
    arguments: '-Tasks @("Build")'

- ${{ if parameters.Official }}:

  - template: templates/CodeSigning.yml@self
    parameters:
      codesigning_path: '$(Build.ArtifactStagingDirectory)\Release'
      codesigning_pattern: | 
        '*.ps1'
        '*.psm1'

  - task: ArchiveFiles@2
    displayName: üì¶ Archive Files
    inputs:
      rootFolderOrFile: '$(Build.ArtifactStagingDirectory)\Release'
      includeRootFolder: false
      archiveType: 'zip'
      archiveFile: '$(Build.ArtifactStagingDirectory)/EnterprisePolicies_v$(GitVersion.SemVer).zip'
      replaceExistingArchive: true

  - task: GithubRelease@1 
    displayName: 'Create GitHub Release'
    condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
    inputs:
      gitHubConnection: 'github.com_faix'
      action: 'create'
      repositoryName: microsoft/PowerPlatform-EnterprisePolicies
      target: '$(Build.SourceVersion)'
      tagSource: userSpecifiedTag
      tag: v$(GitVersion.SemVer)
      changeLogCompareToRelease: 'lastFullRelease'
      changeLogType: 'commitBased'
      assets: |
          $(Build.ArtifactStagingDirectory)/EnterprisePolicies_v$(GitVersion.SemVer).zip